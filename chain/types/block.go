package types

import (
	"github.com/crytic/medusa-geth/common"
	"github.com/crytic/medusa-geth/core"
	"github.com/crytic/medusa-geth/core/types"
)

// Block represents a rudimentary block structure generated by sending messages to a test chain.
type Block struct {
	// Hash represents the block hash for this block.
	Hash common.Hash

	// Header represents the block header for this current block.
	Header *types.Header

	// Messages represent internal EVM core.Message objects. Messages are derived from transactions after validation
	// of a transaction occurs and can be thought of as an internal EVM transaction. It contains typical transaction
	// fields plainly (e.g., no transaction signature is included, the sender is derived and simply supplied as a field
	// in a message).
	Messages []*core.Message

	// MessageResults represents the results recorded while executing transactions.
	MessageResults []*MessageResults

	// BaseContext stores the initial (base) block context before the execution of any transactions
	// within the block. Since transactions that use cheatcodes can affect the block header
	// permanently, we need to store the original values so that we can maintain execution
	// semantics and allow for the chain to be clone-able.
	BaseContext *BaseBlockContext
}

// NewBlock returns a new Block with the provided parameters.
func NewBlock(header *types.Header) *Block {
	// Create our block and return it
	block := &Block{
		Hash:           header.Hash(),
		Header:         header,
		Messages:       make([]*core.Message, 0),
		MessageResults: make([]*MessageResults, 0),
		BaseContext: NewBaseBlockContext(
			header.Number.Uint64(),
			header.Time,
			header.BaseFee,
			header.Coinbase,
		),
	}
	return block
}
