package fuzzing

import (
	"github.com/trailofbits/medusa/utils"
	"math/big"
)

// integerRandomBias defines the probability a generated integer will be entirely random rather than mutated from base
// integers.
const integerRandomBias = 0.2
// stringRandomBias defines the probability a generated string will be entirely random rather than mutated from base
// strings.
const stringRandomBias = 0.2
// bytesRandomBias defines the probability a generated byte array will be entirely random rather than mutated from base
// byte arrays.
const bytesRandomBias = 0.2

// txGeneratorMutation represents an interface for a provider used to generate transaction fields and call arguments
// using mutation-based approaches against items within the corpus, such as AST literals.
type txGeneratorMutation struct {
	// baseIntegers represents the base integer values to be used in mutations.
	baseIntegers []*big.Int
	// baseStrings represents the base strings values to be used in mutations.
	baseStrings []string
	// baseBytes represents the base byte arrays to be used in mutations.
	baseBytes [][]byte

	maxMutationRounds int

	// txGeneratorRandom is included to inherit from the random generator
	*txGeneratorRandom
}

// newTxGeneratorMutation creates a new txGeneratorMutation using a provided corpus to seed base-values for mutation.
func newTxGeneratorMutation(corpus *Corpus) *txGeneratorMutation {
	// Obtain our list of integers as a big int pointer array.
	corpusIntegers := corpus.Integers()
	formattedBaseIntegers := make([]*big.Int, len(corpusIntegers))
	for i := 0; i < len(corpusIntegers); i++ {
		formattedBaseIntegers[i] = &corpusIntegers[i]
	}

	// Create and return our generator
	generator := &txGeneratorMutation{
		baseIntegers: formattedBaseIntegers,
		baseStrings: corpus.Strings(),
		baseBytes: corpus.Bytes(),
		maxMutationRounds: 3,
		txGeneratorRandom: newTxGeneratorRandom(),
	}
	return generator
}

// integerMutationMethods define methods which take a big integer and a set of inputs and
// transform the integer with a random input and operation. This is used in a loop to create
// mutated integer values.
var integerMutationMethods = []func(*txGeneratorMutation, *big.Int, ...*big.Int) *big.Int {
	func(g *txGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Add a random input
		return big.NewInt(0).Add(x, inputs[g.randomProvider.Int() % len(inputs)])
	},
	func(g *txGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Subtract a random input
		return big.NewInt(0).Sub(x, inputs[g.randomProvider.Int() % len(inputs)])
	},
	func(g *txGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Multiply a random input
		return big.NewInt(0).Mul(x, inputs[g.randomProvider.Int() % len(inputs)])
	},
	func(g *txGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Divide a random input
		divisor := inputs[g.randomProvider.Int() % len(inputs)]
		if divisor.Cmp(big.NewInt(0)) == 0 {
			return big.NewInt(1) // leave unchanged if divisor was zero (would've caused panic)
		}
		return big.NewInt(0).Div(x, divisor)
	},
	func(g *txGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Modulo divide a random input
		divisor := inputs[g.randomProvider.Int() % len(inputs)]
		if divisor.Cmp(big.NewInt(0)) == 0 {
			return big.NewInt(0).Set(x) // leave unchanged if divisor was zero (would've caused panic)
		}
		return big.NewInt(0).Mod(x, divisor)
	},
}

var bytesMutationMethods = []func(*txGeneratorMutation, []byte, ...[]byte) []byte {
	// Replace a random index with a random byte
	func(g *txGeneratorMutation, b []byte, inputs ...[]byte ) []byte {
		b[g.randomProvider.Int() % len(b)] = byte(g.randomProvider.Int() % 256)
		return b
	},
	// Flip a random byte
	func(g *txGeneratorMutation, b []byte, inputs ...[]byte ) []byte {
		i := g.randomProvider.Int() % len(b)
		b[i] = b[i] ^ (1 << (g.randomProvider.Int() % 8))
		return b
	},
	// Add a random byte at a random position
	func(g *txGeneratorMutation, b []byte, inputs ...[]byte ) []byte {
		i := g.randomProvider.Int() % len(b)
		by := byte(g.randomProvider.Int() % 256)
		if len(b) == 0 {
			return []byte { by }
		} else if i >= len(b) {
			return append(b, by)
		} else {
			return append(b[:i], append([]byte{by}, b[i:]...)...)
		}
	},
	// Remove a random byte
	func(g *txGeneratorMutation, b []byte, inputs ...[]byte ) []byte {
		i := g.randomProvider.Int() % len(b)
		return append(b[:i], b[i+1:]...)
	},
}

var stringMutationMethods = []func(*txGeneratorMutation, string, ...string) string {
	// Replace a random index with a random character
	func(g *txGeneratorMutation, s string, inputs ...string) string {
		r := []rune(s)
		r[g.randomProvider.Int() % len(s)] = rune(32 + g.randomProvider.Int() % 95)
		return string(r)
	},
	// Flip a random bit
	func(g *txGeneratorMutation, s string, inputs ...string) string {
		r := []rune(s)
		i := g.randomProvider.Int() % len(s)
		r[i] = r[i] ^ (1 << (g.randomProvider.Int() % 8))
		return string(r)
	},
	// Add a random character at a random position
	func(g *txGeneratorMutation, s string, inputs ...string) string {
		i := g.randomProvider.Int() % len(s)
		c := string(rune(32 + g.randomProvider.Int() % 95))
		return s[:i] + c + s[i+1:]
	},
	// Remove a random character
	func(g *txGeneratorMutation, s string, inputs ...string) string {
		i := g.randomProvider.Int() % len(s)
		return s[:i] + s[i+1:]
	},
}

func (g *txGeneratorMutation) getMutationParams(inputsLen int) (int, int) {
	g.randomProviderLock.Lock()
	inputIdx := g.randomProvider.Int() % inputsLen
	mutationCount := g.randomProvider.Int() % (g.maxMutationRounds + 1)
	g.randomProviderLock.Unlock()

	return inputIdx, mutationCount
}


// generateInteger generates/selects an integer to use when populating transaction fields.
func (g *txGeneratorMutation) generateInteger(worker *fuzzerWorker, signed bool, bitLength int) *big.Int {
	// If our bias directs us to, use the random generator instead
	g.randomProviderLock.Lock()
	randomGeneratorDecision := g.randomProvider.Float32()
	g.randomProviderLock.Unlock()
	if randomGeneratorDecision < integerRandomBias {
		return g.txGeneratorRandom.generateInteger(worker, signed, bitLength)
	}

	// Calculate our integer bounds
	min, max := utils.GetIntegerConstraints(signed, bitLength)

	// Determine additional inputs based off the value type
	var inputs []*big.Int
	inputs = append(inputs,  g.baseIntegers...)
	if signed {
		inputs = append(inputs, big.NewInt(0), big.NewInt(1), big.NewInt(-1), big.NewInt(2), min, max)
	} else {
		inputs = append(inputs, big.NewInt(1), big.NewInt(2), min, max) // zero is included in minimum
	}

	inputIdx, mutationCount := g.getMutationParams(len(inputs))
	input := inputs[inputIdx]

	for i := 0; i < mutationCount; i++ {
		// Mutate input
		g.randomProviderLock.Lock()
		input = integerMutationMethods[g.randomProvider.Int() % len(integerMutationMethods)](g, input, inputs...)
		g.randomProviderLock.Unlock()

		// Correct value boundaries (underflow/overflow)
		input = utils.ConstrainIntegerToBounds(input, min, max)
	}
	return input
}

func (g *txGeneratorMutation) generateBytes(worker *fuzzerWorker) []byte {
	// If we have no inputs or our bias directs us to, use the random generator instead
	inputs := g.baseBytes
	g.randomProviderLock.Lock()
	randomGeneratorDecision := g.randomProvider.Float32()
	g.randomProviderLock.Unlock()
	if len(inputs) == 0 || randomGeneratorDecision < bytesRandomBias {
		return g.txGeneratorRandom.generateBytes(worker)
	}

	// Create a copy of a random input to mutate
	inputIdx, mutationCount := g.getMutationParams(len(inputs))
	input := make([]byte, len(inputs[inputIdx]))
	copy(input, inputs[inputIdx])

	// Mutate the data for our desired number of rounds
	for i := 0; i < mutationCount; i++ {
		g.randomProviderLock.Lock()
		input = bytesMutationMethods[g.randomProvider.Int() % len(bytesMutationMethods)](g, input, inputs...)
		g.randomProviderLock.Unlock()
	}

	return input
}

func (g *txGeneratorMutation) generateString(worker *fuzzerWorker) string {
	// If we have no inputs or our bias directs us to, use the random generator instead
	inputs := g.baseStrings
	g.randomProviderLock.Lock()
	randomGeneratorDecision := g.randomProvider.Float32()
	g.randomProviderLock.Unlock()
	if len(inputs) == 0 || randomGeneratorDecision < stringRandomBias {
		return g.txGeneratorRandom.generateString(worker)
	}

	// Obtain a random input to mutate
	inputIdx, mutationCount := g.getMutationParams(len(inputs))
	input := inputs[inputIdx]

	// Mutate the data for our desired number of rounds
	for i := 0; i < mutationCount; i++ {
		g.randomProviderLock.Lock()
		input = stringMutationMethods[g.randomProvider.Int() % len(stringMutationMethods)](g, input, inputs...)
		g.randomProviderLock.Unlock()
	}

	return input
}
