package fuzzing

import (
	"context"
	"errors"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	compilationTypes "github.com/trailofbits/medusa/compilation/types"
	"github.com/trailofbits/medusa/fuzzing/config"
	fuzzerTypes "github.com/trailofbits/medusa/fuzzing/types"
	"github.com/trailofbits/medusa/fuzzing/value_generation"
	"github.com/trailofbits/medusa/utils"
	"golang.org/x/exp/slices"
	"sync"
	"time"
)

// Fuzzer represents an Ethereum smart contract fuzzing provider.
type Fuzzer struct {
	// config describes the project configuration which the fuzzing is targeting.
	config config.ProjectConfig

	// senders describes a set of account addresses used to send state changing calls in fuzzing campaigns.
	senders []common.Address

	// deployer describes an account address used to deploy contracts in fuzzing campaigns.
	deployer common.Address

	// contracts describes the contracts to be targeted
	contracts []fuzzerTypes.Contract

	// BaseValueSet represents a value_generation.BaseValueSet containing input values for our fuzz tests.
	BaseValueSet *value_generation.BaseValueSet

	// ctx describes the context for the fuzzing run, used to cancel running operations.
	ctx context.Context
	// ctxCancelFunc describes a function which can be used to cancel the fuzzing operations ctx tracks.
	ctxCancelFunc context.CancelFunc

	// generator defines our fuzzing approach to generate function inputs.
	generator value_generation.ValueGenerator
	// workers represents the work threads created by this Fuzzer when Start invokes a fuzz operation.
	workers []*FuzzerWorker
	// metrics represents the metrics for the fuzzing campaign.
	metrics *FuzzerMetrics

	// testCaseProviders describes test runners used by the Fuzzer.
	testCaseProviders []TestCaseProvider
	// testCases tracks tests generated by testCaseProviders and registered with the Fuzzer.
	testCases []TestCase
	// testCasesLock provides thread-synchronization to avoid race conditions when accessing or updating test cases.
	testCasesLock sync.Mutex
	// testCasesFinished describes test cases already reported as having been finalized.
	testCasesFinished map[string]TestCase
}

// NewFuzzer returns an instance of a new Fuzzer provided a project configuration, or an error if one is encountered
// while initializing the code.
func NewFuzzer(config config.ProjectConfig) (*Fuzzer, error) {
	// Parse the senders addresses from our account config.
	senders := make([]common.Address, 0)
	for _, sender := range config.Fuzzing.SenderAddresses {
		// Parse our provided account string
		address, err := utils.HexStringToAddress(sender)
		if err != nil {
			return nil, err
		}

		// Add it to our senders list
		senders = append(senders, *address)
	}

	// Parse the deployer address from our account config
	deployer, err := utils.HexStringToAddress(config.Fuzzing.DeployerAddress)
	if err != nil {
		return nil, err
	}

	// Create and return our fuzzing instance.
	fuzzer := &Fuzzer{
		config:            config,
		senders:           senders,
		deployer:          *deployer,
		BaseValueSet:      value_generation.NewBaseValueSet(),
		contracts:         make([]fuzzerTypes.Contract, 0),
		testCaseProviders: make([]TestCaseProvider, 0),
		testCases:         make([]TestCase, 0),
		testCasesFinished: make(map[string]TestCase),
	}

	// If we have a compilation config
	if fuzzer.config.Compilation != nil {
		// Compile the targets specified in the compilation config
		fmt.Printf("Compiling targets (platform '%s') ...\n", fuzzer.config.Compilation.Platform)
		compilations, compilationOutput, err := (*fuzzer.config.Compilation).Compile()
		if err != nil {
			return nil, err
		}
		fmt.Printf(compilationOutput)

		// Add our compilation targets
		fuzzer.AddCompilationTargets(compilations)
	}

	// Register any default providers if specified.
	if fuzzer.config.Fuzzing.Testing.PropertyTesting.Enabled {
		fuzzer.RegisterTestProvider(NewPropertyTestCaseProvider())
	}
	if fuzzer.config.Fuzzing.Testing.AssertionTesting.Enabled {
		// TODO: Add assertion test provider.
	}
	return fuzzer, nil
}

// Contracts exposes the contract definitions registered with the Fuzzer.
func (f *Fuzzer) Contracts() []fuzzerTypes.Contract {
	return slices.Clone(f.contracts)
}

// Config exposes the underlying project configuration provided to the Fuzzer.
func (f *Fuzzer) Config() config.ProjectConfig {
	return f.config
}

// SenderAddresses exposes the account addresses from which state changing fuzzed transactions will be sent by a
// FuzzerWorker.
func (f *Fuzzer) SenderAddresses() []common.Address {
	return slices.Clone(f.senders)
}

// DeployerAddress exposes the account address from which contracts will be deployed by a FuzzerWorker.
func (f *Fuzzer) DeployerAddress() common.Address {
	return f.deployer
}

// TestCases exposes the underlying tests run during the fuzzing campaign.
func (f *Fuzzer) TestCases() []TestCase {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// Collect all test cases and return them.
	testCases := make([]TestCase, 0)
	for i := range f.testCases {
		testCases = append(testCases, f.testCases[i])
	}
	return testCases
}

// TestCasesWithStatus exposes the underlying tests with the provided status.
func (f *Fuzzer) TestCasesWithStatus(status TestCaseStatus) []TestCase {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// Collect all test cases with matching statuses.
	matchingTests := make([]TestCase, 0)
	for i := range f.testCases {
		if f.testCases[i].Status() == status {
			matchingTests = append(matchingTests, f.testCases[i])
		}
	}
	return matchingTests
}

// RegisterTestCase is used by TestCaseProvider to register a TestCase with the Fuzzer.
func (f *Fuzzer) RegisterTestCase(testCase TestCase) {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// Append our test case to our list
	f.testCases = append(f.testCases, testCase)
}

// ReportTestCaseFinished is used by TestCaseProvider to report a TestCase status as finalized.
func (f *Fuzzer) ReportTestCaseFinished(testCase TestCase) {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// If we already reported this test case as finished, stop
	if _, alreadyExists := f.testCasesFinished[testCase.ID()]; alreadyExists {
		return
	}

	// Otherwise now mark the test case as finished.
	f.testCasesFinished[testCase.ID()] = testCase

	// We only log here if we're not configured to stop on the first test failure. This is because the fuzzer prints
	// results on exit, so we avoid duplicate messages.
	if !f.config.Fuzzing.Testing.StopOnFailedTest {
		fmt.Printf("\n[%s] %s\n%s\n\n", testCase.Status(), testCase.Name(), testCase.Message())
	}

	// If the config specifies, we stop after the first failed test reported.
	if testCase.Status() == TestCaseStatusFailed && f.config.Fuzzing.Testing.StopOnFailedTest {
		f.Stop()
	}
}

// RegisterTestProvider registers a TestCaseProvider to the fuzzer to execute tests during fuzzing campaigns.
func (f *Fuzzer) RegisterTestProvider(testCaseProvider TestCaseProvider) {
	f.testCaseProviders = append(f.testCaseProviders, testCaseProvider)
}

// AddCompilationTargets takes a compilation and updates the Fuzzer state with additional Fuzzer.Contracts
// definitions and Fuzzer.BaseValueSet values.
func (f *Fuzzer) AddCompilationTargets(compilations []compilationTypes.Compilation) {
	// Loop for each contract in each compilation and deploy it to the test node.
	for _, comp := range compilations {
		for _, source := range comp.Sources {
			// Seed our base value set from every source's AST
			f.BaseValueSet.SeedFromAst(source.Ast)

			// Loop for every contract and register it in our contract definitions
			for contractName := range source.Contracts {
				contract := source.Contracts[contractName]
				contractDefinition := fuzzerTypes.NewContract(contractName, &contract)
				f.contracts = append(f.contracts, *contractDefinition)
			}
		}
	}
}

// Start begins a fuzzing operation on the provided project configuration. This operation will not return until an error
// is encountered or the fuzzing operation has completed. Its execution can be cancelled using the Stop method.
// Returns an error if one is encountered.
func (f *Fuzzer) Start() error {
	// If we have no test providers, stop immediately as no tests will be run.
	if len(f.testCaseProviders) == 0 {
		return errors.New("no test providers were registered with the fuzzer")
	}

	// Create our running context (allows us to cancel across threads)
	f.ctx, f.ctxCancelFunc = context.WithCancel(context.Background())

	// If we set a timeout, create the timeout context now, as we're about to begin fuzzing.
	if f.config.Fuzzing.Timeout > 0 {
		fmt.Printf("Running with timeout of %d seconds\n", f.config.Fuzzing.Timeout)
		f.ctx, f.ctxCancelFunc = context.WithTimeout(f.ctx, time.Duration(f.config.Fuzzing.Timeout)*time.Second)
	}

	// Initialize our metrics and generator.
	f.metrics = newFuzzerMetrics(f.config.Fuzzing.Workers)
	f.generator = value_generation.NewValueGeneratorMutation(f.BaseValueSet) // TODO: make this configurable after adding more options

	// Initialize our test cases and providers
	f.testCasesLock.Lock()
	f.testCases = make([]TestCase, 0)
	f.testCasesFinished = make(map[string]TestCase)
	f.testCasesLock.Unlock()
	for _, testProvider := range f.testCaseProviders {
		testProvider.OnFuzzerStarting(f)
	}

	// We create a test node for each thread we intend to create. Fuzzer workers can stop if they hit some resource
	// limit such as a memory limit, at which point we'll recreate them in our loop, putting them into the same index.
	// For now, we create our available index queue before initializing some providers and entering our main loop.
	fmt.Printf("Creating %d workers ...\n", f.config.Fuzzing.Workers)
	availableWorkerIndexes := make([]int, f.config.Fuzzing.Workers)
	availableWorkerIndexedLock := sync.Mutex{}
	for i := 0; i < len(availableWorkerIndexes); i++ {
		availableWorkerIndexes[i] = i
	}

	// Start our printing loop now that we're about to begin fuzzing.
	go f.runMetricsPrintLoop()

	// Finally, we create our fuzz workers in a loop, using a channel to block when we reach capacity.
	// If we encounter any errors, we stop.
	f.workers = make([]*FuzzerWorker, f.config.Fuzzing.Workers)
	threadReserveChannel := make(chan struct{}, f.config.Fuzzing.Workers)
	working := true
	var err error
	for err == nil && working {
		// Send an item into our channel to queue up a spot. This will block us if we hit capacity until a worker
		// slot is freed up.
		threadReserveChannel <- struct{}{}

		// Pop a worker index off of our queue
		availableWorkerIndexedLock.Lock()
		workerIndex := availableWorkerIndexes[0]
		availableWorkerIndexes = availableWorkerIndexes[1:]
		availableWorkerIndexedLock.Unlock()

		// Run our goroutine. This should take our queued struct out of the channel once it's done,
		// keeping us at our desired thread capacity.
		go func(workerIndex int) {
			// Create a new worker for this fuzzing.
			worker := newFuzzerWorker(f, workerIndex)
			f.workers[workerIndex] = worker

			// Update the type provider with our event
			for _, testProvider := range f.testCaseProviders {
				testProvider.OnWorkerCreated(worker)
			}

			// Run the worker and check if we received a cancelled signal, or we encountered an error.
			ctxCancelled, workerErr := worker.run()
			if workerErr != nil {
				err = workerErr
			}

			// If we received a cancelled signal, signal our exit from the working loop.
			if working && ctxCancelled {
				working = false
			}

			// Free our worker id before unblocking our channel, as a free one will be expected.
			availableWorkerIndexedLock.Lock()
			availableWorkerIndexes = append(availableWorkerIndexes, workerIndex)
			availableWorkerIndexedLock.Unlock()

			// Update the type provider with our event
			for _, testProvider := range f.testCaseProviders {
				testProvider.OnWorkerDestroyed(worker)
			}

			// Unblock our channel by freeing our capacity of another item, making way for another worker.
			<-threadReserveChannel
		}(workerIndex)
	}

	// Wait for every worker to be freed, so we don't have a race condition when reporting the order
	// of events to our test provider.
	for {
		// Obtain the count of free workers.
		availableWorkerIndexedLock.Lock()
		freeWorkers := len(availableWorkerIndexes)
		availableWorkerIndexedLock.Unlock()

		// We keep waiting until every worker is free
		if freeWorkers == len(f.workers) {
			break
		} else {
			time.Sleep(50 * time.Millisecond)
		}
	}

	// Signal to our test providers that we are stopping fuzzing.
	for _, testProvider := range f.testCaseProviders {
		testProvider.OnFuzzerStopping(f)
	}

	// Print our test case results
	fmt.Printf("\n")
	fmt.Printf("Fuzzer stopped, test results follow below ...\n")
	for _, testCase := range f.testCases {
		if testCase.Status() == TestCaseStatusFailed {
			fmt.Printf("[%s] %s\n%s\n\n", testCase.Status(), testCase.Name(), testCase.Message())
		} else {
			fmt.Printf("[%s] %s\n", testCase.Status(), testCase.Name())
		}
	}

	// Return any encountered error.
	return err
}

// Stop stops a running operation invoked by the Start method. This method may return before complete operation teardown
// occurs.
func (f *Fuzzer) Stop() {
	// Call the cancel function on our running context to stop all working goroutines
	if f.ctxCancelFunc != nil {
		f.ctxCancelFunc()
	}
}

// runMetricsPrintLoop prints metrics to the console in a loop until ctx signals a stopped operation.
func (f *Fuzzer) runMetricsPrintLoop() {
	// Define our start time
	startTime := time.Now()

	// Define cached variables for our metrics to calculate deltas.
	var lastTransactionsTested, lastSequencesTested, lastWorkerStartupCount uint64
	lastPrintedTime := time.Time{}
	for {
		// Obtain our metrics
		transactionsTested := f.metrics.TransactionsTested()
		sequencesTested := f.metrics.SequencesTested()
		workerStartupCount := f.metrics.WorkerStartupCount()

		// Calculate time elapsed since the last update
		secondsSinceLastUpdate := time.Now().Sub(lastPrintedTime).Seconds()

		// Print a metrics update
		fmt.Printf(
			"fuzz: elapsed: %s, call: %d (%d/sec), seq/s: %d, hitmemlimit: %d/s\n",
			time.Now().Sub(startTime).Round(time.Second),
			transactionsTested,
			uint64(float64(transactionsTested-lastTransactionsTested)/secondsSinceLastUpdate),
			uint64(float64(sequencesTested-lastSequencesTested)/secondsSinceLastUpdate),
			uint64(float64(workerStartupCount-lastWorkerStartupCount)/secondsSinceLastUpdate),
		)

		// Update our delta tracking metrics
		lastPrintedTime = time.Now()
		lastTransactionsTested = transactionsTested
		lastSequencesTested = sequencesTested
		lastWorkerStartupCount = workerStartupCount

		// If we reached our transaction threshold, halt
		testLimit := f.config.Fuzzing.TestLimit
		if testLimit > 0 && transactionsTested >= testLimit {
			fmt.Printf("transaction test limit reached, halting now ...\n")
			f.Stop()
		}

		// Sleep for a second
		time.Sleep(time.Second * 3)

		// If ctx signalled to stop the operation, return immediately.
		select {
		case <-f.ctx.Done():
			return
		default:
			break
		}
	}
}
