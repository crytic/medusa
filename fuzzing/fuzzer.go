package fuzzing

import (
	"context"
	"errors"
	"fmt"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core"
	"github.com/trailofbits/medusa/chain"
	compilationTypes "github.com/trailofbits/medusa/compilation/types"
	"github.com/trailofbits/medusa/fuzzing/config"
	fuzzerTypes "github.com/trailofbits/medusa/fuzzing/types"
	"github.com/trailofbits/medusa/fuzzing/value_generation"
	"github.com/trailofbits/medusa/utils"
	"golang.org/x/exp/slices"
	"math/big"
	"sync"
	"time"
)

// Fuzzer represents an Ethereum smart contract fuzzing provider.
type Fuzzer struct {
	// config describes the project configuration which the fuzzing is targeting.
	config config.ProjectConfig

	// senders describes a set of account addresses used to send state changing calls in fuzzing campaigns.
	senders []common.Address

	// deployer describes an account address used to deploy contracts in fuzzing campaigns.
	deployer common.Address

	// contracts describes the contracts to be targeted
	contracts []fuzzerTypes.Contract

	// BaseValueSet represents a value_generation.BaseValueSet containing input values for our fuzz tests.
	BaseValueSet *value_generation.BaseValueSet

	// ctx describes the context for the fuzzing run, used to cancel running operations.
	ctx context.Context
	// ctxCancelFunc describes a function which can be used to cancel the fuzzing operations ctx tracks.
	ctxCancelFunc context.CancelFunc

	// generator defines our fuzzing approach to generate function inputs.
	generator value_generation.ValueGenerator
	// workers represents the work threads created by this Fuzzer when Start invokes a fuzz operation.
	workers []*FuzzerWorker
	// metrics represents the metrics for the fuzzing campaign.
	metrics *FuzzerMetrics

	// testCaseProviders describes test runners used by the Fuzzer.
	testCaseProviders []TestCaseProvider
	// testCases tracks tests generated by testCaseProviders and registered with the Fuzzer.
	testCases []TestCase
	// testCasesLock provides thread-synchronization to avoid race conditions when accessing or updating test cases.
	testCasesLock sync.Mutex
	// testCasesFinished describes test cases already reported as having been finalized.
	testCasesFinished map[string]TestCase

	// testChainSetupFunc describes the function to use to set up a new test chain's initial state prior to fuzzing.
	testChainSetupFunc TestChainSetupFunc
}

// TestChainSetupFunc describes a function which sets up a test chain's initial state prior to fuzzing.
type TestChainSetupFunc func(fuzzer *Fuzzer, testChain *chain.TestChain) error

// NewFuzzer returns an instance of a new Fuzzer provided a project configuration, or an error if one is encountered
// while initializing the code.
func NewFuzzer(config config.ProjectConfig) (*Fuzzer, error) {
	// Parse the senders addresses from our account config.
	senders, err := utils.HexStringsToAddresses(config.Fuzzing.SenderAddresses)
	if err != nil {
		return nil, err
	}

	// Parse the deployer address from our account config
	deployer, err := utils.HexStringToAddress(config.Fuzzing.DeployerAddress)
	if err != nil {
		return nil, err
	}

	// Create and return our fuzzing instance.
	fuzzer := &Fuzzer{
		config:             config,
		senders:            senders,
		deployer:           deployer,
		BaseValueSet:       value_generation.NewBaseValueSet(),
		contracts:          make([]fuzzerTypes.Contract, 0),
		testCaseProviders:  make([]TestCaseProvider, 0),
		testCases:          make([]TestCase, 0),
		testCasesFinished:  make(map[string]TestCase),
		testChainSetupFunc: deploymentStrategyCompilationConfig,
	}

	// If we have a compilation config
	if fuzzer.config.Compilation != nil {
		// Compile the targets specified in the compilation config
		fmt.Printf("Compiling targets (platform '%s') ...\n", fuzzer.config.Compilation.Platform)
		compilations, compilationOutput, err := (*fuzzer.config.Compilation).Compile()
		if err != nil {
			return nil, err
		}
		fmt.Printf(compilationOutput)

		// Add our compilation targets
		fuzzer.AddCompilationTargets(compilations)
	}

	// Register any default providers if specified.
	if fuzzer.config.Fuzzing.Testing.PropertyTesting.Enabled {
		fuzzer.RegisterTestProvider(NewPropertyTestCaseProvider())
	}
	if fuzzer.config.Fuzzing.Testing.AssertionTesting.Enabled {
		// TODO: Add assertion test provider.
	}
	return fuzzer, nil
}

// Contracts exposes the contract definitions registered with the Fuzzer.
func (f *Fuzzer) Contracts() []fuzzerTypes.Contract {
	return slices.Clone(f.contracts)
}

// Config exposes the underlying project configuration provided to the Fuzzer.
func (f *Fuzzer) Config() config.ProjectConfig {
	return f.config
}

// SenderAddresses exposes the account addresses from which state changing fuzzed transactions will be sent by a
// FuzzerWorker.
func (f *Fuzzer) SenderAddresses() []common.Address {
	return slices.Clone(f.senders)
}

// DeployerAddress exposes the account address from which contracts will be deployed by a FuzzerWorker.
func (f *Fuzzer) DeployerAddress() common.Address {
	return f.deployer
}

// TestCases exposes the underlying tests run during the fuzzing campaign.
func (f *Fuzzer) TestCases() []TestCase {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// Collect all test cases and return them.
	testCases := make([]TestCase, 0)
	for i := range f.testCases {
		testCases = append(testCases, f.testCases[i])
	}
	return testCases
}

// TestCasesWithStatus exposes the underlying tests with the provided status.
func (f *Fuzzer) TestCasesWithStatus(status TestCaseStatus) []TestCase {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// Collect all test cases with matching statuses.
	matchingTests := make([]TestCase, 0)
	for i := range f.testCases {
		if f.testCases[i].Status() == status {
			matchingTests = append(matchingTests, f.testCases[i])
		}
	}
	return matchingTests
}

// RegisterTestCase is used by TestCaseProvider to register a TestCase with the Fuzzer.
func (f *Fuzzer) RegisterTestCase(testCase TestCase) {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// Append our test case to our list
	f.testCases = append(f.testCases, testCase)
}

// ReportTestCaseFinished is used by TestCaseProvider to report a TestCase status as finalized.
func (f *Fuzzer) ReportTestCaseFinished(testCase TestCase) {
	// Acquire a thread lock to avoid race conditions
	f.testCasesLock.Lock()
	defer f.testCasesLock.Unlock()

	// If we already reported this test case as finished, stop
	if _, alreadyExists := f.testCasesFinished[testCase.ID()]; alreadyExists {
		return
	}

	// Otherwise now mark the test case as finished.
	f.testCasesFinished[testCase.ID()] = testCase

	// We only log here if we're not configured to stop on the first test failure. This is because the fuzzer prints
	// results on exit, so we avoid duplicate messages.
	if !f.config.Fuzzing.Testing.StopOnFailedTest {
		fmt.Printf("\n[%s] %s\n%s\n\n", testCase.Status(), testCase.Name(), testCase.Message())
	}

	// If the config specifies, we stop after the first failed test reported.
	if testCase.Status() == TestCaseStatusFailed && f.config.Fuzzing.Testing.StopOnFailedTest {
		f.Stop()
	}
}

// RegisterTestProvider registers a TestCaseProvider to the fuzzer to execute tests during fuzzing campaigns.
func (f *Fuzzer) RegisterTestProvider(testCaseProvider TestCaseProvider) {
	f.testCaseProviders = append(f.testCaseProviders, testCaseProvider)
}

// AddCompilationTargets takes a compilation and updates the Fuzzer state with additional Fuzzer.Contracts
// definitions and Fuzzer.BaseValueSet values.
func (f *Fuzzer) AddCompilationTargets(compilations []compilationTypes.Compilation) {
	// Loop for each contract in each compilation and deploy it to the test node.
	for _, comp := range compilations {
		for _, source := range comp.Sources {
			// Seed our base value set from every source's AST
			f.BaseValueSet.SeedFromAst(source.Ast)

			// Loop for every contract and register it in our contract definitions
			for contractName := range source.Contracts {
				contract := source.Contracts[contractName]
				contractDefinition := fuzzerTypes.NewContract(contractName, &contract)
				f.contracts = append(f.contracts, *contractDefinition)
			}
		}
	}
}

// createTestChain creates a test chain with the account balance allocations specified by the config.
func (f *Fuzzer) createTestChain() (*chain.TestChain, error) {
	// Create our genesis allocations.
	// NOTE: Sharing GenesisAlloc between nodes will result in some accounts not being funded for some reason.
	genesisAlloc := make(core.GenesisAlloc)

	// Fund all of our sender addresses in the genesis block
	initBalance := new(big.Int).Div(abi.MaxInt256, big.NewInt(2)) // TODO: make this configurable
	for _, sender := range f.senders {
		genesisAlloc[sender] = core.GenesisAccount{
			Balance: initBalance,
		}
	}

	// Fund our deployer address in the genesis block
	genesisAlloc[f.deployer] = core.GenesisAccount{
		Balance: initBalance,
	}

	// Create our test chain with our basic allocations.
	testChain, err := chain.NewTestChain(genesisAlloc)
	return testChain, err
}

// deploymentStrategyCompilationConfig is a TestChainSetupFunc which sets up the base test chain state by deploying
// all contracts which take no constructor parameters to the chain using the config-specified deployer account address.
// Returns an error if one occurs.
func deploymentStrategyCompilationConfig(fuzzer *Fuzzer, testChain *chain.TestChain) error {
	// Loop for each contract in each compilation and deploy it to the test chain.
	for i := 0; i < len(fuzzer.contracts); i++ {
		// Obtain the currently indexed contract.
		contract := fuzzer.contracts[i]

		// If the contract has no constructor args, deploy it. Only these contracts are supported for now.
		if len(contract.CompiledContract().Abi.Constructor.Inputs) == 0 {
			// Deploy the contract using our deployer address.
			_, _, err := testChain.DeployContract(contract.CompiledContract(), fuzzer.deployer)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Start begins a fuzzing operation on the provided project configuration. This operation will not return until an error
// is encountered or the fuzzing operation has completed. Its execution can be cancelled using the Stop method.
// Returns an error if one is encountered.
func (f *Fuzzer) Start() error {
	// If we have no test providers, stop immediately as no tests will be run.
	if len(f.testCaseProviders) == 0 {
		return errors.New("no test providers were registered with the fuzzer")
	}

	// Create our running context (allows us to cancel across threads)
	f.ctx, f.ctxCancelFunc = context.WithCancel(context.Background())

	// If we set a timeout, create the timeout context now, as we're about to begin fuzzing.
	if f.config.Fuzzing.Timeout > 0 {
		fmt.Printf("Running with timeout of %d seconds\n", f.config.Fuzzing.Timeout)
		f.ctx, f.ctxCancelFunc = context.WithTimeout(f.ctx, time.Duration(f.config.Fuzzing.Timeout)*time.Second)
	}

	// Initialize our metrics and generator.
	f.metrics = newFuzzerMetrics(f.config.Fuzzing.Workers)
	f.generator = value_generation.NewValueGeneratorMutation(f.BaseValueSet) // TODO: make this configurable after adding more options

	// Initialize our test cases and providers
	f.testCasesLock.Lock()
	f.testCases = make([]TestCase, 0)
	f.testCasesFinished = make(map[string]TestCase)
	f.testCasesLock.Unlock()
	for _, testProvider := range f.testCaseProviders {
		err := testProvider.OnFuzzerStarting(f)
		if err != nil {
			return err
		}
	}

	// Create our test chain
	baseTestChain, err := f.createTestChain()
	if err != nil {
		return err
	}

	// Set it up with our deployment/setup strategy defined by the fuzzer.
	err = f.testChainSetupFunc(f, baseTestChain)
	if err != nil {
		return err
	}

	// We create a test node for each thread we intend to create. Fuzzer workers can stop if they hit some resource
	// limit such as a memory limit, at which point we'll recreate them in our loop, putting them into the same index.
	// For now, we create our available index queue before initializing some providers and entering our main loop.
	fmt.Printf("Creating %d workers ...\n", f.config.Fuzzing.Workers)
	availableWorkerIndexes := make([]int, f.config.Fuzzing.Workers)
	availableWorkerIndexedLock := sync.Mutex{}
	for i := 0; i < len(availableWorkerIndexes); i++ {
		availableWorkerIndexes[i] = i
	}

	// Start our printing loop now that we're about to begin fuzzing.
	go f.runMetricsPrintLoop()

	// Finally, we create our fuzz workers in a loop, using a channel to block when we reach capacity.
	// If we encounter any errors, we stop.
	f.workers = make([]*FuzzerWorker, f.config.Fuzzing.Workers)
	threadReserveChannel := make(chan struct{}, f.config.Fuzzing.Workers)
	working := true
	for err == nil && working {
		// Send an item into our channel to queue up a spot. This will block us if we hit capacity until a worker
		// slot is freed up.
		threadReserveChannel <- struct{}{}

		// Pop a worker index off of our queue
		availableWorkerIndexedLock.Lock()
		workerIndex := availableWorkerIndexes[0]
		availableWorkerIndexes = availableWorkerIndexes[1:]
		availableWorkerIndexedLock.Unlock()

		// Run our goroutine. This should take our queued struct out of the channel once it's done,
		// keeping us at our desired thread capacity. If we encounter an error, we store it and continue
		// processing the cleanup logic to exit gracefully.
		go func(workerIndex int) {
			// Create a new worker for this fuzzing.
			worker := newFuzzerWorker(f, workerIndex)
			f.workers[workerIndex] = worker

			// Update the type provider with our event
			for _, testProvider := range f.testCaseProviders {
				workerCreatedErr := testProvider.OnWorkerCreated(worker)
				if err == nil && workerCreatedErr != nil {
					err = workerCreatedErr
					break
				}
			}

			// Run the worker and check if we received a cancelled signal, or we encountered an error.
			if err == nil {
				ctxCancelled, workerErr := worker.run(baseTestChain)
				if workerErr != nil {
					err = workerErr
				}

				// If we received a cancelled signal, signal our exit from the working loop.
				if working && ctxCancelled {
					working = false
				}
			}

			// Free our worker id before unblocking our channel, as a free one will be expected.
			availableWorkerIndexedLock.Lock()
			availableWorkerIndexes = append(availableWorkerIndexes, workerIndex)
			availableWorkerIndexedLock.Unlock()

			// Update the type provider with our event
			for _, testProvider := range f.testCaseProviders {
				workerDestroyedErr := testProvider.OnWorkerDestroyed(worker)
				if err == nil && workerDestroyedErr != nil {
					err = workerDestroyedErr
					break
				}
			}

			// Unblock our channel by freeing our capacity of another item, making way for another worker.
			<-threadReserveChannel
		}(workerIndex)
	}

	// Wait for every worker to be freed, so we don't have a race condition when reporting the order
	// of events to our test provider.
	for {
		// Obtain the count of free workers.
		availableWorkerIndexedLock.Lock()
		freeWorkers := len(availableWorkerIndexes)
		availableWorkerIndexedLock.Unlock()

		// We keep waiting until every worker is free
		if freeWorkers == len(f.workers) {
			break
		} else {
			time.Sleep(50 * time.Millisecond)
		}
	}

	// Now that we've gracefully ensured all goroutines have ceased, we can immediately return our error if we have
	// one.
	if err != nil {
		return err
	}

	// Signal to our test providers that we are stopping fuzzing.
	for _, testProvider := range f.testCaseProviders {
		err = testProvider.OnFuzzerStopping(f)
		if err != nil {
			return err
		}
	}

	// Print our test case results
	fmt.Printf("\n")
	fmt.Printf("Fuzzer stopped, test results follow below ...\n")
	for _, testCase := range f.testCases {
		if testCase.Status() == TestCaseStatusFailed {
			fmt.Printf("[%s] %s\n%s\n\n", testCase.Status(), testCase.Name(), testCase.Message())
		} else {
			fmt.Printf("[%s] %s\n", testCase.Status(), testCase.Name())
		}
	}

	// Return any encountered error.
	return err
}

// Stop stops a running operation invoked by the Start method. This method may return before complete operation teardown
// occurs.
func (f *Fuzzer) Stop() {
	// Call the cancel function on our running context to stop all working goroutines
	if f.ctxCancelFunc != nil {
		f.ctxCancelFunc()
	}
}

// runMetricsPrintLoop prints metrics to the console in a loop until ctx signals a stopped operation.
func (f *Fuzzer) runMetricsPrintLoop() {
	// Define our start time
	startTime := time.Now()

	// Define cached variables for our metrics to calculate deltas.
	var lastTransactionsTested, lastSequencesTested, lastWorkerStartupCount uint64
	lastPrintedTime := time.Time{}
	for {
		// Obtain our metrics
		transactionsTested := f.metrics.TransactionsTested()
		sequencesTested := f.metrics.SequencesTested()
		workerStartupCount := f.metrics.WorkerStartupCount()

		// Calculate time elapsed since the last update
		secondsSinceLastUpdate := time.Now().Sub(lastPrintedTime).Seconds()

		// Print a metrics update
		fmt.Printf(
			"fuzz: elapsed: %s, call: %d (%d/sec), seq/s: %d, hitmemlimit: %d/s\n",
			time.Now().Sub(startTime).Round(time.Second),
			transactionsTested,
			uint64(float64(transactionsTested-lastTransactionsTested)/secondsSinceLastUpdate),
			uint64(float64(sequencesTested-lastSequencesTested)/secondsSinceLastUpdate),
			uint64(float64(workerStartupCount-lastWorkerStartupCount)/secondsSinceLastUpdate),
		)

		// Update our delta tracking metrics
		lastPrintedTime = time.Now()
		lastTransactionsTested = transactionsTested
		lastSequencesTested = sequencesTested
		lastWorkerStartupCount = workerStartupCount

		// If we reached our transaction threshold, halt
		testLimit := f.config.Fuzzing.TestLimit
		if testLimit > 0 && transactionsTested >= testLimit {
			fmt.Printf("transaction test limit reached, halting now ...\n")
			f.Stop()
		}

		// Sleep for a second
		time.Sleep(time.Second * 3)

		// If ctx signalled to stop the operation, return immediately.
		select {
		case <-f.ctx.Done():
			return
		default:
			break
		}
	}
}
