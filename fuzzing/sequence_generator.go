package fuzzing

import (
	"fmt"
	"math/big"
	"math/rand"

	"github.com/crytic/medusa/fuzzing/calls"
	"github.com/crytic/medusa/fuzzing/contracts"
	"github.com/crytic/medusa/fuzzing/valuegeneration"
	"github.com/crytic/medusa/utils"
	"github.com/crytic/medusa/utils/randomutils"
)

// CallSequenceGenerator generates call sequences iteratively per element, for use in fuzzing campaigns. It is attached
// to a FuzzerWorker and uses its runtime context
type CallSequenceGenerator struct {
	// worker describes the parent FuzzerWorker using this mutator. Calls will be generated against deployed contract
	// methods known to the worker.
	worker *FuzzerWorker

	// config describes the weights to use for each weighted random CallSequenceGeneratorMutationStrategy this
	// CallSequenceGenerator will use when generating new call sequences.
	config *CallSequenceGeneratorConfig

	// baseSequence describes the internal call sequence generated by InitializeNextSequence to use as a base when providing
	// potentially further mutated values with PopSequenceElement iteratively.
	baseSequence calls.CallSequence

	// fetchIndex describes the current position in the baseSequence which defines the next element to be mutated and
	// returned when calling PopSequenceElement.
	fetchIndex int

	// mutationStrategyChooser is a weighted random selector of functions that prepare the CallSequenceGenerator with
	// a baseSequence derived from corpus entries.
	mutationStrategyChooser *randomutils.WeightedRandomChooser[CallSequenceGeneratorMutationStrategy]
}

// CallSequenceGeneratorConfig defines the configuration for a CallSequenceGenerator to be created and used by a
// FuzzerWorker to generate call sequences in a fuzzing campaign.
type CallSequenceGeneratorConfig struct {
	// NewSequenceProbability defines the probability that the CallSequenceGenerator should generate an entirely new
	// sequence rather than mutating one from the corpus.
	NewSequenceProbability float32

	// Prepend defines the weight that the CallSequenceGenerator should use the call sequence
	// generation strategy of taking the head of a corpus sequence (without mutations) and append newly generated calls
	// to the end of it.
	Prepend uint64

	// Append defines the weight that the CallSequenceGenerator should use the call sequence
	// generation strategy of taking the tail of a corpus sequence (without mutations) and prepend newly generated calls
	// to the start of it.
	Append uint64

	// Splice defines the weight that the CallSequenceGenerator should use the call sequence
	// generation strategy of taking two corpus sequences (without mutations) and splicing them before joining them
	// together.
	Splice uint64

	// Interleave defines the weight that the CallSequenceGenerator should use the call
	// sequence generation strategy of taking two corpus sequences (without mutations) and interleaving a random
	// number of calls from each.
	Interleave uint64

	// PrependAndMutate defines the weight that the CallSequenceGenerator should use the call sequence
	// generation strategy of taking the head of a corpus sequence (with mutations) and append newly generated calls
	// to the end of it.
	PrependAndMutate uint64

	// AppendAndMutate defines the weight that the CallSequenceGenerator should use the call sequence
	// generation strategy of taking the tao; of a corpus sequence (with mutations) and prepend newly generated calls
	// to the start of it.
	AppendAndMutate uint64

	// SpliceAndMutate defines the weight that the CallSequenceGenerator should use the call sequence
	// generation strategy of taking two corpus sequences (with mutations) and splicing them before joining them
	// together.
	SpliceAndMutate uint64

	// InterleaveAndMutate defines the weight that the CallSequenceGenerator should use the call
	// sequence generation strategy of taking two corpus sequences (with mutations) and interleaving a random
	// number of calls from each.
	InterleaveAndMutate uint64

	// ValueGenerator defines the value provider to use when generating new values for call sequences. This is used both
	// for ABI call data generation, and generation of additional values such as the "value" field of a
	// transaction/call.
	ValueGenerator valuegeneration.ValueGenerator

	// ValueMutator defines the value provider to use when mutating corpus call sequences.
	ValueMutator valuegeneration.ValueMutator
}

// CallSequenceGeneratorFunc defines a method used to populate a provided call sequence with generated calls.
// Returns an optional PrefetchModifyCallFunc to be executed prior to the fetching of each element, or an error if
// one occurs.
type CallSequenceGeneratorFunc func(provider *rand.Rand, sequenceGenerator func() (calls.CallSequence, error), sequence calls.CallSequence) error

// CallSequenceGeneratorMutationStrategy defines a structure for a mutation strategy used by a CallSequenceGenerator.
type CallSequenceGeneratorMutationStrategy struct {
	// CallSequenceGeneratorFunc describes a method used to populate a provided call sequence.
	CallSequenceGeneratorFunc CallSequenceGeneratorFunc
	//  Whether to mutate
	Mutate bool
}

// NewCallSequenceGenerator creates a CallSequenceGenerator to generate call sequences for use in fuzzing campaigns.
func NewCallSequenceGenerator(worker *FuzzerWorker, config *CallSequenceGeneratorConfig) *CallSequenceGenerator {
	generator := &CallSequenceGenerator{
		worker:                  worker,
		config:                  config,
		mutationStrategyChooser: randomutils.NewWeightedRandomChooser[CallSequenceGeneratorMutationStrategy](),
	}

	generator.mutationStrategyChooser.AddChoices(
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: prependFromCorpus,
			},
			new(big.Int).SetUint64(config.Prepend),
		),
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: appendFromCorpus,
			},
			new(big.Int).SetUint64(config.Append),
		),
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: spliceCorpus,
			},
			new(big.Int).SetUint64(config.Splice),
		),
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: interleaveCorpus,
			},
			new(big.Int).SetUint64(config.Interleave),
		),
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: prependFromCorpus,
				Mutate:                    true,
			},
			new(big.Int).SetUint64(config.PrependAndMutate),
		),
		randomutils.NewWeightedRandomChoice(
			CallSequenceGeneratorMutationStrategy{
				CallSequenceGeneratorFunc: appendFromCorpus,
				Mutate:                    true,
			},
			new(big.Int).SetUint64(config.AppendAndMutate),
		),
	)

	return generator
}

// InitializeNextSequence prepares the CallSequenceGenerator for generating a new sequence. Each element can be
// obtained by calling PopSequenceElement iteratively.
// Returns a boolean indicating whether the initialized sequence is a newly generated sequence (rather than an
// unmodified one loaded from the corpus), or an error if one occurred.
func (g *CallSequenceGenerator) InitializeNextSequence() (bool, error) {
	// Reset the state of our generator.
	g.baseSequence = make(calls.CallSequence, g.worker.fuzzer.config.Fuzzing.CallSequenceLength)
	g.fetchIndex = 0

	// Check if there are any previously un-executed corpus call sequences. If there are, the fuzzer should execute
	// those first.
	unexecutedSequence := g.worker.fuzzer.corpus.UnexecutedCallSequence()
	if unexecutedSequence != nil {
		g.baseSequence = *unexecutedSequence
		return false, nil
	}

	// We'll decide whether to create a new call sequence or mutating existing corpus call sequences. Any entries we
	// leave as nil will be populated by a newly generated call prior to being fetched from this provider.

	// If this provider has no corpus mutation methods or corpus call sequences, we return a call sequence with
	// nil elements to signal that we want an entirely new sequence.
	if g.mutationStrategyChooser.ChoiceCount() == 0 || g.worker.fuzzer.corpus.ActiveMutableSequenceCount() == 0 {
		return true, nil
	}

	// Determine whether we will generate a corpus based mutated sequence.
	if g.worker.randomProvider.Float32() > g.config.NewSequenceProbability {
		// Get a random mutator function.
		corpusMutationFunc, err := g.mutationStrategyChooser.Choose()
		if err != nil {
			return true, fmt.Errorf("could not generate a corpus mutation derived call sequence due to an error obtaining a mutation method: %v", err)
		}

		// If we have a corpus mutation method, call it to generate our base sequence, then set the pre-fetch modify
		// call function.
		if corpusMutationFunc != nil && corpusMutationFunc.CallSequenceGeneratorFunc != nil {
			fetchFromCorpusAndMutate := func() (calls.CallSequence, error) {
				corpusSequence, err := g.worker.fuzzer.corpus.RandomMutationTargetSequence()
				if err != nil {
					return corpusSequence, fmt.Errorf("could not generate a corpus mutation derived call sequence due to an error obtaining a mutation target: %v", err)
				}
				if corpusMutationFunc.Mutate {
					err = g.mutateCallSequence(corpusSequence)
				}
				return corpusSequence, err
			}

			err = corpusMutationFunc.CallSequenceGeneratorFunc(g.worker.randomProvider, fetchFromCorpusAndMutate, g.baseSequence)
			if err != nil {
				return true, fmt.Errorf("could not generate a corpus mutation derived call sequence due to an error executing a mutation method: %v", err)
			}
		}
	}
	return true, nil
}

// PopSequenceElement obtains the next element for our call sequence requested by InitializeNextSequence. If there are no elements
// left to return, this method returns nil. If an error occurs, it is returned instead.
func (g *CallSequenceGenerator) PopSequenceElement() (*calls.CallSequenceElement, error) {
	// If the call sequence length is zero, there is no work to be done.
	if g.fetchIndex >= len(g.baseSequence) {
		return nil, nil
	}

	// Obtain our base call element
	element := g.baseSequence[g.fetchIndex]

	// If it is nil, we generate an entirely new call. Otherwise, we apply pre-execution modifications.
	var err error
	if element == nil {
		element, err = g.generateNewElement()
		if err != nil {
			return nil, err
		}
	}

	// Update the element with the current nonce for the associated chain.
	element.Call.FillFromTestChainProperties(g.worker.chain)

	// Update our base sequence, advance our position, and return the processed element from this round.
	g.baseSequence[g.fetchIndex] = element
	g.fetchIndex++
	return element, nil
}

// generateNewElement generates a new call sequence element which targets a method in a contract
// deployed to the CallSequenceGenerator's parent FuzzerWorker chain, with fuzzed call data.
// Returns the call sequence element, or an error if one was encountered.
func (g *CallSequenceGenerator) generateNewElement() (*calls.CallSequenceElement, error) {
	// Check to make sure that we have any functions to call
	if len(g.worker.stateChangingMethods) == 0 && len(g.worker.pureMethods) == 0 {
		return nil, fmt.Errorf("cannot generate fuzzed call as there are no methods to call")
	}

	// Only call view functions if there are no state-changing methods
	var callOnlyPureFunctions bool
	if len(g.worker.stateChangingMethods) == 0 && len(g.worker.pureMethods) > 0 {
		callOnlyPureFunctions = true
	}

	// Select a random method
	// There is a 1/100 chance that a pure method will be invoked or if there are only pure functions that are callable
	var selectedMethod *contracts.DeployedContractMethod
	if (len(g.worker.pureMethods) > 0 && g.worker.randomProvider.Intn(100) == 0) || callOnlyPureFunctions {
		selectedMethod = &g.worker.pureMethods[g.worker.randomProvider.Intn(len(g.worker.pureMethods))]
	} else {
		selectedMethod = &g.worker.stateChangingMethods[g.worker.randomProvider.Intn(len(g.worker.stateChangingMethods))]
	}

	// Select a random sender
	selectedSender := g.worker.fuzzer.senders[g.worker.randomProvider.Intn(len(g.worker.fuzzer.senders))]

	// Generate fuzzed parameters for the function call
	args := make([]any, len(selectedMethod.Method.Inputs))
	for i := 0; i < len(args); i++ {
		// Create our fuzzed parameters.
		input := selectedMethod.Method.Inputs[i]
		args[i] = valuegeneration.GenerateAbiValue(g.config.ValueGenerator, &input.Type)
	}

	// If this is a payable function, generate value to send
	var value *big.Int
	value = big.NewInt(0)
	if selectedMethod.Method.StateMutability == "payable" {
		value = g.config.ValueGenerator.GenerateInteger(false, 64)
	}

	// Create our message using the provided parameters.
	// We fill out some fields and populate the rest from our TestChain properties.
	// TODO: We likely want to make gasPrice fluctuate within some sensible range here.
	msg := calls.NewCallMessageWithAbiValueData(selectedSender, &selectedMethod.Address, 0, value, g.worker.fuzzer.config.Fuzzing.TransactionGasLimit, nil, nil, nil, &calls.CallMessageDataAbiValues{
		Method:      &selectedMethod.Method,
		InputValues: args,
	})

	if g.worker.fuzzer.config.Fuzzing.TestChainConfig.SkipAccountChecks {
		msg.SkipAccountChecks = true
	}

	// Determine our delay values for this element
	blockNumberDelay := uint64(0)
	blockTimestampDelay := uint64(0)
	if g.worker.fuzzer.config.Fuzzing.MaxBlockNumberDelay > 0 {
		blockNumberDelay = g.config.ValueGenerator.GenerateInteger(false, 64).Uint64() % (g.worker.fuzzer.config.Fuzzing.MaxBlockNumberDelay + 1)
	}
	if g.worker.fuzzer.config.Fuzzing.MaxBlockTimestampDelay > 0 {
		blockTimestampDelay = g.config.ValueGenerator.GenerateInteger(false, 64).Uint64() % (g.worker.fuzzer.config.Fuzzing.MaxBlockTimestampDelay + 1)
	}

	// For each block we jump, we need a unique time stamp for chain semantics, so if our block number jump is too small,
	// while our timestamp jump is larger, we cap it.
	if blockNumberDelay > blockTimestampDelay {
		if blockTimestampDelay == 0 {
			blockNumberDelay = 0
		} else {
			blockNumberDelay %= blockTimestampDelay
		}
	}

	// Return our call sequence element.
	return calls.NewCallSequenceElement(selectedMethod.Contract, msg, blockNumberDelay, blockTimestampDelay), nil
}

// mutateCallSequenceElement applies a mutation to a call sequence element, prior to it being fetched from the corpus.
// Returns an error if one occurs.
func (g *CallSequenceGenerator) mutateCallSequence(sequence calls.CallSequence) error {
	// Equal probability of mutating a random element, expanding a random element, swapping a random element, or deleting a random element.
	choice := g.worker.randomProvider.Intn(4)
	if choice == 0 {
		return g.mutateRandomElement(sequence)
	}
	if choice == 1 {
		return expandRandomElement(g.worker.randomProvider, sequence)
	}
	if choice == 2 {
		return swapRandomElement(g.worker.randomProvider, sequence)
	}
	if choice == 3 {
		return deleteRandomElement(g.worker.randomProvider, sequence)
	}

	return nil
}

func (g *CallSequenceGenerator) mutateRandomElement(sequence calls.CallSequence) error {
	element := sequence[g.worker.randomProvider.Intn(len(sequence))]

	// If this element has no ABI value based call data, exit early.
	if element.Call == nil || element.Call.DataAbiValues == nil {
		return nil
	}

	// Loop for each input value and mutate it
	abiValuesMsgData := element.Call.DataAbiValues
	for i := 0; i < len(abiValuesMsgData.InputValues); i++ {
		mutatedInput, err := valuegeneration.MutateAbiValue(g.config.ValueGenerator, g.config.ValueMutator, &abiValuesMsgData.Method.Inputs[i].Type, abiValuesMsgData.InputValues[i])
		if err != nil {
			return fmt.Errorf("error when mutating call sequence input argument: %v", err)
		}
		abiValuesMsgData.InputValues[i] = mutatedInput
	}
	// Re-encode the message's calldata
	element.Call.WithDataAbiValues(abiValuesMsgData)

	return nil
}

func expandRandomElement(provider *rand.Rand, sequence calls.CallSequence) error {
	// Expand the sequence
	expandedSequence := expandRandList(provider, sequence)

	copy(sequence, expandedSequence)

	return nil
}

func swapRandomElement(provider *rand.Rand, sequence calls.CallSequence) error {
	// Swap the element
	swappedSequence := swapRandList(provider, sequence)

	copy(sequence, swappedSequence)

	return nil
}

func deleteRandomElement(provider *rand.Rand, sequence calls.CallSequence) error {
	// Delete the element
	deletedSequence := deleteRandList(provider, sequence)

	copy(sequence, deletedSequence)

	return nil
}

// prependFromCorpus is a CallSequenceGeneratorFunc which prepares a CallSequenceGenerator to generate a sequence
// whose head is based off of an existing corpus call sequence.
// Returns an error if one occurs.
func prependFromCorpus(provider *rand.Rand, sequenceGenerator func() (calls.CallSequence, error), sequence calls.CallSequence) error {
	// Obtain a call sequence from the corpus
	corpusSequence, err := sequenceGenerator()
	if err != nil {
		return fmt.Errorf("could not obtain corpus call sequence for head mutation: %v", err)
	}

	// Determine the length of the slice to be copied in the head.
	maxLength := utils.Min(len(sequence), len(corpusSequence))
	copy(sequence, corpusSequence[:maxLength])

	return nil
}

// appendFromCorpus is a CallSequenceGeneratorFunc which prepares a CallSequenceGenerator to generate a sequence
// whose tail is based off of an existing corpus call sequence.
// Returns an error if one occurs.
func appendFromCorpus(provider *rand.Rand, sequenceGenerator func() (calls.CallSequence, error), sequence calls.CallSequence) error {
	// Obtain a call sequence from the corpus
	corpusSequence, err := sequenceGenerator()
	if err != nil {
		return fmt.Errorf("could not obtain corpus call sequence for tail mutation: %v", err)
	}

	// Determine a random position to slice the call sequence.
	maxLength := utils.Min(len(sequence), len(corpusSequence))
	targetLength := provider.Intn(maxLength) + 1
	copy(sequence[len(sequence)-targetLength:], corpusSequence[len(corpusSequence)-targetLength:])

	return nil
}

// spliceCorpus is a CallSequenceGeneratorFunc which prepares a CallSequenceGenerator to generate a
// sequence which is based off of two corpus call sequence entries, from which a random length head and tail are
// respectively sliced and joined together.
// Returns an error if one occurs.
func spliceCorpus(provider *rand.Rand, sequenceGenerator func() (calls.CallSequence, error), sequence calls.CallSequence) error {
	// Obtain two corpus call sequence entries
	headSequence, err := sequenceGenerator()
	if err != nil {
		return fmt.Errorf("could not obtain tail corpus call sequence for splice-at-random corpus mutation: %v", err)
	}
	tailSequence, err := sequenceGenerator()
	if err != nil {
		return fmt.Errorf("could not obtain tail corpus call sequence for splice-at-random corpus mutation: %v", err)
	}

	// Splice the two sequences
	splicedSequence := spliceAtRandom(provider, headSequence, tailSequence)

	copy(sequence, splicedSequence)

	return nil
}

// interleaveCorpus is a CallSequenceGeneratorFunc which prepares a CallSequenceGenerator to generate a
// sequence which is based off of two corpus call sequence entries, from which a random number of transactions are
// taken and interleaved (each element of one sequence will be followed by an element of the other).
// Returns an error if one occurs.
func interleaveCorpus(provider *rand.Rand, sequenceGenerator func() (calls.CallSequence, error), sequence calls.CallSequence) error {
	// Obtain two corpus call sequence entries
	firstSequence, err := sequenceGenerator()
	if err != nil {
		return fmt.Errorf("could not obtain first corpus call sequence for interleave-at-random corpus mutation: %v", err)
	}
	secondSequence, err := sequenceGenerator()
	if err != nil {
		return fmt.Errorf("could not obtain second corpus call sequence for interleave-at-random corpus mutation: %v", err)
	}

	// Interleave the two sequences
	interleavedSequence := interleaveAtRandom(provider, firstSequence, secondSequence)

	copy(sequence, interleavedSequence)

	return nil
}

// expandAt expands the element at index k by t times.
func expandAt[T any](xs []*T, k int, t int) []*T {
	if len(xs) == 0 {
		return xs
	}
	return append(append(xs[:k], repeat(xs[k], t)...), xs[k+1:]...)
}

// repeat replicates an element t times.
func repeat[T any](v *T, t int) []*T {
	res := make([]*T, t)
	for i := range res {
		res[i] = v
	}
	return res
}

// expandRandList expands a random element of the list by 1 to 32 times.
func expandRandList[T any](provider *rand.Rand, xs []*T) []*T {
	l := len(xs)
	if l == 0 || l >= 32 {
		return xs
	}
	k := provider.Intn(l)
	t := provider.Intn(utils.Min(32, l)) + 1
	return expandAt(xs, k, t)
}

// deleteAt deletes the element at the given index.
func deleteAt[T any](xs []*T, n int) []*T {
	xs[n] = nil
	return xs
}

// deleteRandList deletes a random element from the list.
func deleteRandList[T any](provider *rand.Rand, xs []*T) []*T {
	if len(xs) == 0 {
		return xs
	}
	k := provider.Intn(len(xs))
	return deleteAt(xs, k)
}

// swapAt swaps two elements in the list.
func swapAt[T any](xs []*T, i, j int) []*T {
	xs[i], xs[j] = xs[j], xs[i]
	return xs
}

// swapRandList swaps two random elements in the list.
func swapRandList[T any](provider *rand.Rand, xs []*T) []*T {
	if len(xs) == 0 {
		return xs
	}
	i, j := rand.Intn(len(xs)), rand.Intn(len(xs))
	return swapAt(xs, utils.Min(i, j), utils.Max(i, j))
}

// spliceAtRandom splices two lists at random positions.
func spliceAtRandom[T any](provider *rand.Rand, xs1, xs2 []*T) []*T {
	idx1, idx2 := rand.Intn(len(xs1)), rand.Intn(len(xs2))
	return append(xs1[:idx1], xs2[idx2:]...)
}

// interleaveAtRandom interleaves two lists at random positions.
func interleaveAtRandom[T any](provider *rand.Rand, xs1, xs2 []*T) []*T {
	idx1, idx2 := rand.Intn(len(xs1)), rand.Intn(len(xs2))
	return interleaveLL(xs1[:idx1], xs2[:idx2])
}

// interleaveLL interleaves two lists.
func interleaveLL[T any](a, b []*T) []*T {
	if len(a) == 0 {
		return b
	}
	if len(b) == 0 {
		return a
	}
	return append([]*T{a[0], b[0]}, interleaveLL(a[1:], b[1:])...)
}
