// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package config

import (
	"encoding/json"
	"math/big"

	"github.com/crytic/medusa/chain/config"
	"github.com/ethereum/go-ethereum/common/hexutil"
)

var _ = (*fuzzingConfigMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (f FuzzingConfig) MarshalJSON() ([]byte, error) {
	type FuzzingConfig struct {
		Workers                 int                       `json:"workers"`
		WorkerResetLimit        int                       `json:"workerResetLimit"`
		Timeout                 int                       `json:"timeout"`
		TestLimit               uint64                    `json:"testLimit"`
		CallSequenceLength      int                       `json:"callSequenceLength"`
		CorpusDirectory         string                    `json:"corpusDirectory"`
		CoverageEnabled         bool                      `json:"coverageEnabled"`
		TargetContracts         []string                  `json:"targetContracts"`
		TargetContractsBalances []*hexutil.Big            `json:"targetContractsBalances"`
		ConstructorArgs         map[string]map[string]any `json:"constructorArgs"`
		DeployerAddress         string                    `json:"deployerAddress"`
		SenderAddresses         []string                  `json:"senderAddresses"`
		MaxBlockNumberDelay     uint64                    `json:"blockNumberDelayMax"`
		MaxBlockTimestampDelay  uint64                    `json:"blockTimestampDelayMax"`
		BlockGasLimit           uint64                    `json:"blockGasLimit"`
		TransactionGasLimit     uint64                    `json:"transactionGasLimit"`
		Testing                 TestingConfig             `json:"testing"`
		TestChainConfig         config.TestChainConfig    `json:"chainConfig"`
	}
	var enc FuzzingConfig
	enc.Workers = f.Workers
	enc.WorkerResetLimit = f.WorkerResetLimit
	enc.Timeout = f.Timeout
	enc.TestLimit = f.TestLimit
	enc.CallSequenceLength = f.CallSequenceLength
	enc.CorpusDirectory = f.CorpusDirectory
	enc.CoverageEnabled = f.CoverageEnabled
	enc.TargetContracts = f.TargetContracts
	if f.TargetContractsBalances != nil {
		enc.TargetContractsBalances = make([]*hexutil.Big, len(f.TargetContractsBalances))
		for k, v := range f.TargetContractsBalances {
			enc.TargetContractsBalances[k] = (*hexutil.Big)(v)
		}
	}
	enc.ConstructorArgs = f.ConstructorArgs
	enc.DeployerAddress = f.DeployerAddress
	enc.SenderAddresses = f.SenderAddresses
	enc.MaxBlockNumberDelay = f.MaxBlockNumberDelay
	enc.MaxBlockTimestampDelay = f.MaxBlockTimestampDelay
	enc.BlockGasLimit = f.BlockGasLimit
	enc.TransactionGasLimit = f.TransactionGasLimit
	enc.Testing = f.Testing
	enc.TestChainConfig = f.TestChainConfig
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (f *FuzzingConfig) UnmarshalJSON(input []byte) error {
	type FuzzingConfig struct {
		Workers                 *int                      `json:"workers"`
		WorkerResetLimit        *int                      `json:"workerResetLimit"`
		Timeout                 *int                      `json:"timeout"`
		TestLimit               *uint64                   `json:"testLimit"`
		CallSequenceLength      *int                      `json:"callSequenceLength"`
		CorpusDirectory         *string                   `json:"corpusDirectory"`
		CoverageEnabled         *bool                     `json:"coverageEnabled"`
		TargetContracts         []string                  `json:"targetContracts"`
		TargetContractsBalances []*hexutil.Big            `json:"targetContractsBalances"`
		ConstructorArgs         map[string]map[string]any `json:"constructorArgs"`
		DeployerAddress         *string                   `json:"deployerAddress"`
		SenderAddresses         []string                  `json:"senderAddresses"`
		MaxBlockNumberDelay     *uint64                   `json:"blockNumberDelayMax"`
		MaxBlockTimestampDelay  *uint64                   `json:"blockTimestampDelayMax"`
		BlockGasLimit           *uint64                   `json:"blockGasLimit"`
		TransactionGasLimit     *uint64                   `json:"transactionGasLimit"`
		Testing                 *TestingConfig            `json:"testing"`
		TestChainConfig         *config.TestChainConfig   `json:"chainConfig"`
	}
	var dec FuzzingConfig
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Workers != nil {
		f.Workers = *dec.Workers
	}
	if dec.WorkerResetLimit != nil {
		f.WorkerResetLimit = *dec.WorkerResetLimit
	}
	if dec.Timeout != nil {
		f.Timeout = *dec.Timeout
	}
	if dec.TestLimit != nil {
		f.TestLimit = *dec.TestLimit
	}
	if dec.CallSequenceLength != nil {
		f.CallSequenceLength = *dec.CallSequenceLength
	}
	if dec.CorpusDirectory != nil {
		f.CorpusDirectory = *dec.CorpusDirectory
	}
	if dec.CoverageEnabled != nil {
		f.CoverageEnabled = *dec.CoverageEnabled
	}
	if dec.TargetContracts != nil {
		f.TargetContracts = dec.TargetContracts
	}
	if dec.TargetContractsBalances != nil {
		f.TargetContractsBalances = make([]*big.Int, len(dec.TargetContractsBalances))
		for k, v := range dec.TargetContractsBalances {
			f.TargetContractsBalances[k] = (*big.Int)(v)
		}
	}
	if dec.ConstructorArgs != nil {
		f.ConstructorArgs = dec.ConstructorArgs
	}
	if dec.DeployerAddress != nil {
		f.DeployerAddress = *dec.DeployerAddress
	}
	if dec.SenderAddresses != nil {
		f.SenderAddresses = dec.SenderAddresses
	}
	if dec.MaxBlockNumberDelay != nil {
		f.MaxBlockNumberDelay = *dec.MaxBlockNumberDelay
	}
	if dec.MaxBlockTimestampDelay != nil {
		f.MaxBlockTimestampDelay = *dec.MaxBlockTimestampDelay
	}
	if dec.BlockGasLimit != nil {
		f.BlockGasLimit = *dec.BlockGasLimit
	}
	if dec.TransactionGasLimit != nil {
		f.TransactionGasLimit = *dec.TransactionGasLimit
	}
	if dec.Testing != nil {
		f.Testing = *dec.Testing
	}
	if dec.TestChainConfig != nil {
		f.TestChainConfig = *dec.TestChainConfig
	}
	return nil
}
