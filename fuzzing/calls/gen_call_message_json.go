// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package calls

import (
	"encoding/json"
	"math/big"

	"github.com/crytic/medusa-geth/common"
	"github.com/crytic/medusa-geth/common/hexutil"
	"github.com/crytic/medusa-geth/core/types"
)

var _ = (*callMessageMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (c CallMessage) MarshalJSON() ([]byte, error) {
	type CallMessage struct {
		From             common.Address            `json:"from"`
		To               *common.Address           `json:"to"`
		Nonce            uint64                    `json:"nonce"`
		Value            *hexutil.Big              `json:"value"`
		GasLimit         uint64                    `json:"gasLimit"`
		GasPrice         *hexutil.Big              `json:"gasPrice"`
		GasFeeCap        *hexutil.Big              `json:"gasFeeCap"`
		GasTipCap        *hexutil.Big              `json:"gasTipCap"`
		Data             hexutil.Bytes             `json:"data,omitempty"`
		DataAbiValues    *CallMessageDataAbiValues `json:"dataAbiValues,omitempty"`
		AccessList       types.AccessList
		SkipNonceChecks  bool
		SkipFromEOACheck bool
	}
	var enc CallMessage
	enc.From = c.From
	enc.To = c.To
	enc.Nonce = c.Nonce
	enc.Value = (*hexutil.Big)(c.Value)
	enc.GasLimit = c.GasLimit
	enc.GasPrice = (*hexutil.Big)(c.GasPrice)
	enc.GasFeeCap = (*hexutil.Big)(c.GasFeeCap)
	enc.GasTipCap = (*hexutil.Big)(c.GasTipCap)
	enc.Data = c.Data
	enc.DataAbiValues = c.DataAbiValues
	enc.AccessList = c.AccessList
	enc.SkipNonceChecks = c.SkipNonceChecks
	enc.SkipFromEOACheck = c.SkipFromEOACheck
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (c *CallMessage) UnmarshalJSON(input []byte) error {
	type CallMessage struct {
		From             *common.Address           `json:"from"`
		To               *common.Address           `json:"to"`
		Nonce            *uint64                   `json:"nonce"`
		Value            *hexutil.Big              `json:"value"`
		GasLimit         *uint64                   `json:"gasLimit"`
		GasPrice         *hexutil.Big              `json:"gasPrice"`
		GasFeeCap        *hexutil.Big              `json:"gasFeeCap"`
		GasTipCap        *hexutil.Big              `json:"gasTipCap"`
		Data             *hexutil.Bytes            `json:"data,omitempty"`
		DataAbiValues    *CallMessageDataAbiValues `json:"dataAbiValues,omitempty"`
		AccessList       *types.AccessList
		SkipNonceChecks  *bool
		SkipFromEOACheck *bool
	}
	var dec CallMessage
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.From != nil {
		c.From = *dec.From
	}
	if dec.To != nil {
		c.To = dec.To
	}
	if dec.Nonce != nil {
		c.Nonce = *dec.Nonce
	}
	if dec.Value != nil {
		c.Value = (*big.Int)(dec.Value)
	}
	if dec.GasLimit != nil {
		c.GasLimit = *dec.GasLimit
	}
	if dec.GasPrice != nil {
		c.GasPrice = (*big.Int)(dec.GasPrice)
	}
	if dec.GasFeeCap != nil {
		c.GasFeeCap = (*big.Int)(dec.GasFeeCap)
	}
	if dec.GasTipCap != nil {
		c.GasTipCap = (*big.Int)(dec.GasTipCap)
	}
	if dec.Data != nil {
		c.Data = *dec.Data
	}
	if dec.DataAbiValues != nil {
		c.DataAbiValues = dec.DataAbiValues
	}
	if dec.AccessList != nil {
		c.AccessList = *dec.AccessList
	}
	if dec.SkipNonceChecks != nil {
		c.SkipNonceChecks = *dec.SkipNonceChecks
	}
	if dec.SkipFromEOACheck != nil {
		c.SkipFromEOACheck = *dec.SkipFromEOACheck
	}
	return nil
}
