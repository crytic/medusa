package utils

import (
	"encoding/hex"
	"fmt"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"math/big"
)

// DecodeJSONArguments Decode provided map of JSON values for provided list of abi arguments
// This function assumes that the values map is generated by JSON unmarshal function
func DecodeJSONArguments(inputs abi.Arguments, values map[string]any) ([]any, error) {
	if len(inputs) == 0 {
		return nil, nil
	}
	var args = make([]any, len(inputs))
	for i, input := range inputs {
		value, ok := values[input.Name]
		if !ok {
			err := fmt.Errorf("constructor argument not provided for: name: %v", input.Name)
			return nil, err
		}
		arg, err := decodeJSONArgument(&input.Type, value)
		if err != nil {
			err = fmt.Errorf("invalid constructor argument: \n"+
				"name: %v, expected type: %v, value: %v, type of value: %T, error: %s",
				input.Name, input.Type, value, value, err)
			return nil, err
		}
		args[i] = arg
	}
	return args, nil
}

// decodeArgument Decode JSON value for provided ABI type
// This function assumes that the value is generated by JSON unmarshal function
func decodeJSONArgument(inputType *abi.Type, value any) (any, error) {
	var v any
	switch inputType.T {
	case abi.IntTy:
		str, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("")
		}
		val := big.NewInt(0)
		_, success := val.SetString(str, 10)
		if !success {
			return nil, fmt.Errorf("")
		}
		switch inputType.Size {
		case 64:
			v = val.Int64()
		case 32:
			v = int32(val.Int64())
		case 16:
			v = int16(val.Int64())
		case 8:
			v = int8(val.Int64())
		default:
			v = val
		}
	case abi.UintTy:
		str, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("")
		}
		val := big.NewInt(0)
		_, success := val.SetString(str, 10)
		if !success {
			return nil, fmt.Errorf("")
		}
		switch inputType.Size {
		case 64:
			v = val.Uint64()
		case 32:
			v = uint32(val.Uint64())
		case 16:
			v = uint16(val.Uint64())
		case 8:
			v = uint8(val.Uint64())
		default:
			v = val
		}
	case abi.BoolTy:
		str, ok := value.(bool)
		if !ok {
			return nil, fmt.Errorf("")
		}
		v = str
	case abi.StringTy:
		str, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("")
		}
		v = str
	case abi.AddressTy:
		str, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("")
		}
		if !((len(str) == (common.AddressLength*2 + 2)) || (len(str) == common.AddressLength*2)) {
			err := fmt.Errorf("invalid address length (%v)", len(str))
			return nil, err
		}
		addr := common.HexToAddress(str)
		v = addr
	case abi.HashTy:
		str, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("")
		}
		if !((len(str) == (common.HashLength*2 + 2)) || (len(str) == common.HashLength*2)) {
			err := fmt.Errorf("invalid hash length %v", len(str))
			return nil, err
		}
		hash := common.HexToHash(str)
		v = hash
	case abi.BytesTy, abi.FixedBytesTy:
		str, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("")
		}
		if len(str) >= 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X') {
			str = str[2:]
		}
		decodedBytes, err := hex.DecodeString(str)
		if err != nil {
			return nil, err
		}
		v = decodedBytes
	case abi.SliceTy, abi.ArrayTy:
		arr, ok := value.([]any)
		if !ok {
			return nil, fmt.Errorf("")
		}
		temp := make([]any, len(arr))
		for i, e := range arr {
			ele, err := decodeJSONArgument(inputType.Elem, e)
			if err != nil {
				return nil, err
			}
			temp[i] = ele
		}
		v = temp
	// TODO Add support for struct type and fixed point type
	default:
		err := fmt.Errorf("argument type is not supported: %v", inputType)
		return nil, err
	}

	return v, nil
}
